WITH date_range AS (
    SELECT generate_series(
        (SELECT MIN(date) FROM public.robinhood_daily),
        (SELECT MAX(date) FROM public.robinhood_daily),
        '1 day'::interval
    )::date as date
),
all_stocks AS (
    SELECT DISTINCT contract_address
    FROM public.robinhood_daily
    WHERE contract_address IN (
        SELECT contract_address
        FROM public.robinhood_stock_list
        WHERE ticker NOT ILIKE '%%demo token%%'
    )
),
complete_date_stock_grid AS (
    SELECT
        s.contract_address,
        d.date
    FROM all_stocks s
    CROSS JOIN date_range d
),
daily_metrics AS (
    SELECT
        contract_address,
        date,
        SUM(CASE WHEN metric_key = 'total_minted' THEN value ELSE 0 END) as minted,
        SUM(CASE WHEN metric_key = 'total_burned' THEN value ELSE 0 END) as burned,
        MAX(CASE WHEN metric_key = 'Close' THEN value END) as close_price
    FROM public.robinhood_daily
    WHERE metric_key IN ('total_minted', 'total_burned', 'Close')
    GROUP BY contract_address, date
),
complete_data AS (
    SELECT
        g.contract_address,
        g.date,
        COALESCE(dm.minted, 0) as minted,
        COALESCE(dm.burned, 0) as burned,
        dm.close_price
    FROM complete_date_stock_grid g
    LEFT JOIN daily_metrics dm ON g.contract_address = dm.contract_address AND g.date = dm.date
),
prices_with_fill AS (
    SELECT
        contract_address,
        date,
        minted,
        burned,
        close_price,
        COALESCE(
            close_price,
            LAG(close_price) OVER (PARTITION BY contract_address ORDER BY date),
            LAG(close_price, 2) OVER (PARTITION BY contract_address ORDER BY date),
            LAG(close_price, 3) OVER (PARTITION BY contract_address ORDER BY date)
        ) as filled_close_price
    FROM complete_data
),
cumulative_supply AS (
    SELECT
        contract_address,
        date,
        minted,
        burned,
        close_price,
        filled_close_price,
        SUM(minted - burned) OVER (
            PARTITION BY contract_address
            ORDER BY date
            ROWS UNBOUNDED PRECEDING
        ) as total_supply
    FROM prices_with_fill
),
daily_supply_data AS (
    SELECT
        contract_address,
        date,
        total_supply,
        close_price as original_close_price,
        filled_close_price as close_price_used,
        total_supply * filled_close_price as usd_outstanding
    FROM cumulative_supply
    WHERE filled_close_price IS NOT NULL
),
latest_data AS (
    SELECT
        contract_address,
        date,
        total_supply,
        original_close_price,
        close_price_used,
        usd_outstanding,
        ROW_NUMBER() OVER (PARTITION BY contract_address ORDER BY date DESC) as rn
    FROM daily_supply_data
),
seven_days_ago_data AS (
    SELECT
        contract_address,
        date,
        total_supply as total_supply_7d_ago,
        ROW_NUMBER() OVER (PARTITION BY contract_address ORDER BY date DESC) as rn_7d
    FROM daily_supply_data
    WHERE date <= (SELECT MAX(date) - INTERVAL '7 days' FROM daily_supply_data)
)
SELECT
    ld.contract_address,
    rsl.ticker,
    rsl.name,
    ld.usd_outstanding,
    ld.total_supply AS stocks_tokenized,
    ld.close_price_used AS usd_stock_price,
    CASE 
        WHEN sda.total_supply_7d_ago IS NOT NULL AND sda.total_supply_7d_ago > 0 
        THEN ROUND(
            ((ld.total_supply - sda.total_supply_7d_ago) / sda.total_supply_7d_ago * 100)::numeric, 
            2
        )
        ELSE NULL 
    END AS stocks_tokenized_7d_change_pct
FROM latest_data ld
LEFT JOIN public.robinhood_stock_list rsl
    ON ld.contract_address = rsl.contract_address
    AND rsl.ticker NOT ILIKE '%%demo token%%'
LEFT JOIN seven_days_ago_data sda
    ON ld.contract_address = sda.contract_address
    AND sda.rn_7d = 1
WHERE ld.rn = 1
ORDER BY ld.usd_outstanding DESC;